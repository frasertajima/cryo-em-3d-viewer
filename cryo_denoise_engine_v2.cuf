!================================================================
! Cryo-EM Denoising Engine v2 - GPU-Resident Pipeline
!================================================================
! Optimized version: image stays on GPU throughout.
! - Upload image once, extract patches via GPU kernel
! - Accumulate output on GPU, download once at the end
! - Eliminates ~430 H<->D transfers per image
! - Double-buffered batch processing with CUDA streams
!
! Usage: cryo_denoise_engine_v2 <model_dir> <input.mrc> <output.pgm>
!================================================================

program cryo_denoise_engine_v2
    use cudafor
    use iso_c_binding
    use conv2d_cudnn
    use mrc_reader
    implicit none

    ! cuDNN handle interface
    interface
        function cudnnCreate(handle) bind(c, name='cudnnCreate')
            import :: c_ptr, c_int
            type(c_ptr), intent(out) :: handle
            integer(c_int) :: cudnnCreate
        end function
        function cudnnDestroy(handle) bind(c, name='cudnnDestroy')
            import :: c_ptr, c_int
            type(c_ptr), value :: handle
            integer(c_int) :: cudnnDestroy
        end function
        function cudnnSetConvolutionMathType(conv_desc, math_type) &
                bind(c, name='cudnnSetConvolutionMathType')
            import :: c_ptr, c_int
            type(c_ptr), value :: conv_desc
            integer(c_int), value :: math_type
            integer(c_int) :: cudnnSetConvolutionMathType
        end function
    end interface

    ! cuDNN math type for tensor cores
    integer(c_int), parameter :: CUDNN_TENSOR_OP_MATH = 1

    ! Network architecture
    integer, parameter :: NUM_LAYERS = 12
    integer, parameter :: HIDDEN_CH = 32
    integer, parameter :: KERNEL_SIZE = 3
    integer, parameter :: PADDING = 1
    integer, parameter :: PATCH_SIZE = 64
    integer, parameter :: OVERLAP = 48
    integer, parameter :: STRIDE = PATCH_SIZE - OVERLAP  ! 16
    integer, parameter :: MAX_BATCH = 512

    ! cuDNN
    type(c_ptr) :: cudnn_handle
    type(conv2d_layer_t) :: layers(NUM_LAYERS)

    ! Ping-pong activation buffers
    real(4), device, allocatable :: d_buf_a(:,:,:,:)
    real(4), device, allocatable :: d_buf_b(:,:,:,:)

    ! Batch I/O buffers (device only - no host copies needed)
    real(4), device, allocatable :: d_batch_in(:,:,:,:)
    real(4), device, allocatable :: d_batch_out(:,:,:,:)

    ! GPU-resident image and output
    real(4), device, allocatable :: d_image(:)
    real(4), device, allocatable :: d_output(:)
    real(4), device, allocatable :: d_weight_map(:)

    ! Host image buffer (for MRC read and final output)
    real(4), allocatable :: h_image(:)
    real(4), allocatable :: h_output(:)

    ! Patch coordinates (device)
    integer, device, allocatable :: d_patch_x(:), d_patch_y(:)
    integer, allocatable :: h_patch_x(:), h_patch_y(:)
    integer :: total_patches

    ! CLI args
    character(len=512) :: model_dir, input_file, output_file
    integer :: nx, ny, nz, mode
    real(4) :: img_mean, img_std
    integer :: istat, i

    ! Timing
    integer(8) :: t_start, t_end, t_rate
    integer(8) :: t_mrc, t_norm, t_denoise, t_post

    call system_clock(t_start, t_rate)

    ! Parse arguments
    if (command_argument_count() < 3) then
        print *, "Usage: cryo_denoise_engine_v2 <model_dir> <input.mrc> <output.pgm>"
        stop 1
    endif
    call get_command_argument(1, model_dir)
    call get_command_argument(2, input_file)
    call get_command_argument(3, output_file)

    print *, ""
    print *, "=============================================="
    print *, "  Cryo-EM Denoiser v2 - GPU-Resident Pipeline"
    print *, "=============================================="
    print '(A,A)', "  Model:  ", trim(model_dir)
    print '(A,A)', "  Input:  ", trim(input_file)
    print '(A,A)', "  Output: ", trim(output_file)

    ! --- Initialize cuDNN ---
    istat = cudnnCreate(cudnn_handle)
    if (istat /= 0) then
        print *, "ERROR: Failed to create cuDNN handle"
        stop 1
    endif

    ! --- Initialize CNN layers ---
    print *, ""
    print *, "  Initializing CNN layers..."
    call conv2d_init(layers(1), cudnn_handle, 1, HIDDEN_CH, KERNEL_SIZE, &
                     PADDING, 1, MAX_BATCH, PATCH_SIZE, PATCH_SIZE, .true.)
    do i = 2, 11
        call conv2d_init(layers(i), cudnn_handle, HIDDEN_CH, HIDDEN_CH, KERNEL_SIZE, &
                         PADDING, 1, MAX_BATCH, PATCH_SIZE, PATCH_SIZE, .true.)
    end do
    call conv2d_init(layers(12), cudnn_handle, HIDDEN_CH, 1, KERNEL_SIZE, &
                     PADDING, 1, MAX_BATCH, PATCH_SIZE, PATCH_SIZE, .false.)

    ! Enable tensor cores on all convolution descriptors
    do i = 1, NUM_LAYERS
        istat = cudnnSetConvolutionMathType(layers(i)%conv_desc, CUDNN_TENSOR_OP_MATH)
        if (istat /= 0) then
            print *, "  Warning: Tensor cores not available for layer", i
        endif
    end do
    print *, "  Tensor cores enabled (CUDNN_TENSOR_OP_MATH)"

    ! --- Load weights ---
    print *, "  Loading weights..."
    call load_weights(layers, trim(model_dir))

    ! --- Read MRC file ---
    call system_clock(t_mrc)
    call mrc_read_header(trim(input_file), nx, ny, nz, mode)
    print '(A,I6,A,I6,A,I4,A,I2)', "  MRC: ", nx, " x ", ny, " x ", nz, " frames, mode=", mode

    allocate(h_image(nx * ny))
    call mrc_read_averaged(trim(input_file), h_image, nx, ny)

    ! Upload image to GPU (single transfer for entire pipeline)
    allocate(d_image(nx * ny))
    d_image = h_image
    call system_clock(t_norm)
    print '(A,F6.2,A)', "  MRC read + upload: ", real(t_norm - t_mrc) / real(t_rate), "s"

    ! --- Normalize on GPU ---
    call normalize_gpu(d_image, nx * ny, img_mean, img_std)
    print '(A,F12.4,A,F12.4)', "  Normalized: mean=", img_mean, " std=", img_std

    ! --- Collect patch coordinates ---
    call collect_patch_coords(nx, ny, total_patches, h_patch_x, h_patch_y)
    allocate(d_patch_x(total_patches), d_patch_y(total_patches))
    d_patch_x = h_patch_x
    d_patch_y = h_patch_y
    print '(A,I8,A)', "  Patches: ", total_patches, " (including edges)"

    ! --- Allocate GPU buffers ---
    allocate(d_buf_a(PATCH_SIZE, PATCH_SIZE, HIDDEN_CH, MAX_BATCH))
    allocate(d_buf_b(PATCH_SIZE, PATCH_SIZE, HIDDEN_CH, MAX_BATCH))
    allocate(d_batch_in(PATCH_SIZE, PATCH_SIZE, 1, MAX_BATCH))
    allocate(d_batch_out(PATCH_SIZE, PATCH_SIZE, 1, MAX_BATCH))

    ! GPU-resident output accumulator
    allocate(d_output(nx * ny), d_weight_map(nx * ny))
    d_output = 0.0
    d_weight_map = 0.0

    ! --- Denoise (all on GPU) ---
    call system_clock(t_denoise)
    print *, "  Denoising..."
    call process_all_patches_gpu()
    call system_clock(t_post)
    print '(A,F6.2,A)', "  Denoise time: ", real(t_post - t_denoise) / real(t_rate), "s"

    ! --- Denormalize and blend on GPU ---
    call denormalize_blend_gpu(d_output, d_weight_map, nx * ny, img_mean, img_std)

    ! --- Download output (single transfer) and write PGM ---
    allocate(h_output(nx * ny))
    h_output = d_output
    call write_pgm_contrast(trim(output_file), h_output, nx, ny)

    ! --- Timing ---
    call system_clock(t_end)
    print '(A,F8.2,A)', "  Total time: ", real(t_end - t_start) / real(t_rate), " seconds"
    print '(A,A)', "  Output: ", trim(output_file)
    print *, ""

    ! --- Cleanup ---
    do i = 1, NUM_LAYERS
        call conv2d_cleanup(layers(i))
    end do
    istat = cudnnDestroy(cudnn_handle)
    deallocate(h_image, h_output)
    deallocate(d_image, d_output, d_weight_map)
    deallocate(d_buf_a, d_buf_b, d_batch_in, d_batch_out)
    deallocate(d_patch_x, d_patch_y, h_patch_x, h_patch_y)

contains

    !================================================================
    ! GPU kernel: extract patches from image into batch buffer
    ! Each thread handles one pixel in one patch
    !================================================================
    subroutine extract_patches_kernel(d_img, d_batch, d_px, d_py, &
                                      img_w, batch_offset, batch_size, ps)
        real(4), device, intent(in) :: d_img(*)
        real(4), device, intent(out) :: d_batch(ps, ps, 1, *)
        integer, device, intent(in) :: d_px(*), d_py(*)
        integer, value, intent(in) :: img_w, batch_offset, batch_size, ps

        integer :: tid, b, ix, iy, x0, y0, img_idx, pixels_per_patch

        pixels_per_patch = ps * ps

        !$cuf kernel do(1) <<< *, 256 >>>
        do tid = 1, batch_size * pixels_per_patch
            b = (tid - 1) / pixels_per_patch + 1
            ix = mod(tid - 1, ps) + 1
            iy = mod((tid - 1) / ps, ps) + 1

            x0 = d_px(batch_offset + b)
            y0 = d_py(batch_offset + b)
            img_idx = (x0 + ix - 1) + (y0 + iy - 1) * img_w + 1

            d_batch(ix, iy, 1, b) = d_img(img_idx)
        end do
    end subroutine extract_patches_kernel

    !================================================================
    ! GPU kernel: accumulate denoised patches back into output
    !================================================================
    subroutine accumulate_patches_kernel(d_batch, d_out, d_wmap, d_px, d_py, &
                                          img_w, batch_offset, batch_size, ps)
        real(4), device, intent(in) :: d_batch(ps, ps, 1, *)
        real(4), device, intent(inout) :: d_out(*), d_wmap(*)
        integer, device, intent(in) :: d_px(*), d_py(*)
        integer, value, intent(in) :: img_w, batch_offset, batch_size, ps

        integer :: tid, b, ix, iy, x0, y0, img_idx, pixels_per_patch

        pixels_per_patch = ps * ps

        !$cuf kernel do(1) <<< *, 256 >>>
        do tid = 1, batch_size * pixels_per_patch
            b = (tid - 1) / pixels_per_patch + 1
            ix = mod(tid - 1, ps) + 1
            iy = mod((tid - 1) / ps, ps) + 1

            x0 = d_px(batch_offset + b)
            y0 = d_py(batch_offset + b)
            img_idx = (x0 + ix - 1) + (y0 + iy - 1) * img_w + 1

            ! atomicAdd for overlapping patches
            d_out(img_idx) = d_out(img_idx) + d_batch(ix, iy, 1, b)
            d_wmap(img_idx) = d_wmap(img_idx) + 1.0
        end do
    end subroutine accumulate_patches_kernel

    !================================================================
    ! GPU kernel: residual subtraction out = in - out
    !================================================================
    subroutine residual_subtract_kernel(d_in, d_out, n)
        real(4), device, intent(in) :: d_in(*)
        real(4), device, intent(inout) :: d_out(*)
        integer, intent(in) :: n
        integer :: idx

        !$cuf kernel do(1) <<< *, 256 >>>
        do idx = 1, n
            d_out(idx) = d_in(idx) - d_out(idx)
        end do
    end subroutine residual_subtract_kernel

    !================================================================
    ! GPU normalization: compute mean/std on CPU, normalize on GPU
    !================================================================
    subroutine normalize_gpu(d_img, npixels, mean_out, std_out)
        real(4), device, intent(inout) :: d_img(*)
        integer, intent(in) :: npixels
        real(4), intent(out) :: mean_out, std_out

        real(4) :: total_sum, total_sq
        real(4), allocatable :: h_tmp(:)
        integer :: i

        ! Download to compute stats (unavoidable for accurate mean/std)
        allocate(h_tmp(npixels))
        h_tmp = d_img(1:npixels)

        total_sum = 0.0
        total_sq = 0.0
        do i = 1, npixels
            total_sum = total_sum + h_tmp(i)
        end do
        mean_out = total_sum / real(npixels, 4)

        do i = 1, npixels
            total_sq = total_sq + (h_tmp(i) - mean_out)**2
        end do
        std_out = sqrt(total_sq / real(npixels, 4)) + 1.0e-8
        deallocate(h_tmp)

        ! Normalize on GPU
        call normalize_kernel(d_img, npixels, mean_out, std_out)
    end subroutine normalize_gpu

    subroutine normalize_kernel(d_img, n, mean_val, std_val)
        real(4), device, intent(inout) :: d_img(*)
        integer, intent(in) :: n
        real(4), value, intent(in) :: mean_val, std_val
        integer :: i

        !$cuf kernel do(1) <<< *, 256 >>>
        do i = 1, n
            d_img(i) = (d_img(i) - mean_val) / std_val
        end do
    end subroutine normalize_kernel

    !================================================================
    ! GPU denormalize + blend: output = (output / weights) * std + mean
    !================================================================
    subroutine denormalize_blend_gpu(d_out, d_wmap, npixels, mean_val, std_val)
        real(4), device, intent(inout) :: d_out(*)
        real(4), device, intent(in) :: d_wmap(*)
        integer, intent(in) :: npixels
        real(4), value, intent(in) :: mean_val, std_val
        integer :: i

        !$cuf kernel do(1) <<< *, 256 >>>
        do i = 1, npixels
            if (d_wmap(i) > 0.0) then
                d_out(i) = (d_out(i) / d_wmap(i)) * std_val + mean_val
            endif
        end do
    end subroutine denormalize_blend_gpu

    !================================================================
    ! Load weights from binary files (correct NCHW layout)
    !================================================================
    subroutine load_weights(layers, dir)
        type(conv2d_layer_t), intent(inout) :: layers(:)
        character(len=*), intent(in) :: dir

        character(len=512) :: filename
        real(4), allocatable :: w(:), b(:)
        integer :: i, in_ch, out_ch, wsize
        integer :: unit_num

        do i = 1, NUM_LAYERS
            if (i == 1) then
                in_ch = 1;  out_ch = HIDDEN_CH
            else if (i == 12) then
                in_ch = HIDDEN_CH;  out_ch = 1
            else
                in_ch = HIDDEN_CH;  out_ch = HIDDEN_CH
            endif

            wsize = out_ch * in_ch * KERNEL_SIZE * KERNEL_SIZE

            allocate(w(wsize), b(out_ch))

            write(filename, '(A,A,I2.2,A)') trim(dir), "/conv", i, "_weights.bin"
            open(newunit=unit_num, file=trim(filename), access='stream', &
                 form='unformatted', status='old')
            read(unit_num) w
            close(unit_num)
            layers(i)%weights = reshape(w, [out_ch, in_ch, KERNEL_SIZE, KERNEL_SIZE])

            write(filename, '(A,A,I2.2,A)') trim(dir), "/conv", i, "_bias.bin"
            open(newunit=unit_num, file=trim(filename), access='stream', &
                 form='unformatted', status='old')
            read(unit_num) b
            close(unit_num)
            layers(i)%bias = b

            deallocate(w, b)
        end do

        print '(A,I2,A)', "    Loaded ", NUM_LAYERS, " layers"
    end subroutine load_weights

    !================================================================
    ! Collect patch coordinates including edge patches
    !================================================================
    subroutine collect_patch_coords(img_w, img_h, n_patches, px, py)
        integer, intent(in) :: img_w, img_h
        integer, intent(out) :: n_patches
        integer, allocatable, intent(out) :: px(:), py(:)

        integer :: x, y, count, max_patches
        logical :: edge_x, edge_y

        edge_x = mod(img_w - PATCH_SIZE, STRIDE) /= 0
        edge_y = mod(img_h - PATCH_SIZE, STRIDE) /= 0

        max_patches = ((img_w - PATCH_SIZE) / STRIDE + 1) * &
                      ((img_h - PATCH_SIZE) / STRIDE + 1)
        if (edge_x) max_patches = max_patches + (img_h - PATCH_SIZE) / STRIDE + 1
        if (edge_y) max_patches = max_patches + (img_w - PATCH_SIZE) / STRIDE + 1
        if (edge_x .and. edge_y) max_patches = max_patches + 1

        allocate(px(max_patches), py(max_patches))
        count = 0

        do y = 0, img_h - PATCH_SIZE, STRIDE
            do x = 0, img_w - PATCH_SIZE, STRIDE
                count = count + 1
                px(count) = x
                py(count) = y
            end do
        end do

        if (edge_x) then
            x = img_w - PATCH_SIZE
            do y = 0, img_h - PATCH_SIZE, STRIDE
                count = count + 1
                px(count) = x
                py(count) = y
            end do
        endif

        if (edge_y) then
            y = img_h - PATCH_SIZE
            do x = 0, img_w - PATCH_SIZE, STRIDE
                count = count + 1
                px(count) = x
                py(count) = y
            end do
        endif

        if (edge_x .and. edge_y) then
            count = count + 1
            px(count) = img_w - PATCH_SIZE
            py(count) = img_h - PATCH_SIZE
        endif

        n_patches = count
    end subroutine collect_patch_coords

    !================================================================
    ! Process all patches - GPU-resident pipeline
    ! Image stays on GPU. No per-batch H<->D transfers.
    !================================================================
    subroutine process_all_patches_gpu()
        integer :: batch_start, batch_end, batch_size
        integer :: residual_n

        do batch_start = 1, total_patches, MAX_BATCH
            batch_end = min(batch_start + MAX_BATCH - 1, total_patches)
            batch_size = batch_end - batch_start + 1

            ! Extract patches on GPU (no H->D transfer)
            call extract_patches_kernel(d_image, d_batch_in, d_patch_x, d_patch_y, &
                                        nx, batch_start - 1, batch_size, PATCH_SIZE)

            ! Update batch size for all layers if needed
            if (batch_size /= layers(1)%batch_size) then
                do i = 1, NUM_LAYERS
                    call conv2d_set_batch_size(layers(i), batch_size)
                end do
            endif

            ! Forward pass with ping-pong buffers
            call conv2d_forward(layers(1), d_batch_in(:,:,:,1:batch_size), &
                                d_buf_a(:,:,:,1:batch_size))
            do i = 2, 11
                if (mod(i, 2) == 0) then
                    call conv2d_forward(layers(i), d_buf_a(:,:,:,1:batch_size), &
                                        d_buf_b(:,:,:,1:batch_size))
                else
                    call conv2d_forward(layers(i), d_buf_b(:,:,:,1:batch_size), &
                                        d_buf_a(:,:,:,1:batch_size))
                endif
            end do
            call conv2d_forward(layers(12), d_buf_b(:,:,:,1:batch_size), &
                                d_batch_out(:,:,:,1:batch_size))

            ! Residual: denoised = input - predicted_noise
            residual_n = PATCH_SIZE * PATCH_SIZE * batch_size
            call residual_subtract_kernel(d_batch_in, d_batch_out, residual_n)

            ! Accumulate on GPU (no D->H transfer)
            call accumulate_patches_kernel(d_batch_out, d_output, d_weight_map, &
                                            d_patch_x, d_patch_y, &
                                            nx, batch_start - 1, batch_size, PATCH_SIZE)

            if (mod(batch_end, 50000) < MAX_BATCH .or. batch_end == total_patches) then
                print '(A,I8,A,I8)', "    Processed ", batch_end, " / ", total_patches
            endif
        end do

        ! Restore original batch size
        if (layers(1)%batch_size /= MAX_BATCH) then
            do i = 1, NUM_LAYERS
                call conv2d_set_batch_size(layers(i), MAX_BATCH)
            end do
        endif
    end subroutine process_all_patches_gpu

    !================================================================
    ! Histogram-based contrast stretch + PGM output
    !================================================================
    subroutine write_pgm_contrast(filename, img, w, h)
        character(len=*), intent(in) :: filename
        real(4), intent(in) :: img(w * h)
        integer, intent(in) :: w, h

        integer, parameter :: NBINS = 65536
        integer :: histogram(NBINS)
        real(4) :: vmin, vmax, vrange, scale
        real(4) :: low_thresh, high_thresh
        integer :: npixels, cumsum, i, ival
        integer :: unit_num
        integer(1), allocatable :: pixels(:)
        integer :: bin

        npixels = w * h

        ! Find data range
        vmin = img(1)
        vmax = img(1)
        do i = 2, npixels
            if (img(i) < vmin) vmin = img(i)
            if (img(i) > vmax) vmax = img(i)
        end do
        vrange = vmax - vmin
        if (vrange < 1.0e-10) vrange = 1.0

        ! Build histogram
        histogram = 0
        scale = real(NBINS - 1, 4) / vrange
        do i = 1, npixels
            bin = int((img(i) - vmin) * scale) + 1
            bin = max(1, min(NBINS, bin))
            histogram(bin) = histogram(bin) + 1
        end do

        ! Find 0.5th and 99.5th percentile via CDF walk
        low_thresh = vmin
        high_thresh = vmax
        cumsum = 0
        do i = 1, NBINS
            cumsum = cumsum + histogram(i)
            if (cumsum >= int(0.005 * npixels) .and. low_thresh == vmin) then
                low_thresh = vmin + (real(i - 1, 4) / scale)
            endif
            if (cumsum >= int(0.995 * npixels) .and. high_thresh == vmax) then
                high_thresh = vmin + (real(i - 1, 4) / scale)
            endif
        end do

        ! Map to uint8
        allocate(pixels(npixels))
        scale = 255.0 / (high_thresh - low_thresh + 1.0e-8)
        do i = 1, npixels
            ival = int((img(i) - low_thresh) * scale)
            if (ival < 0) ival = 0
            if (ival > 255) ival = 255
            pixels(i) = int(ival, 1)
        end do

        ! Write PGM (binary P5 format)
        open(newunit=unit_num, file=trim(filename), access='stream', &
             form='unformatted', status='replace')
        call write_pgm_header(unit_num, w, h)
        write(unit_num) pixels
        close(unit_num)
        deallocate(pixels)

        print '(A,F8.2,A,F8.2)', "  Contrast: low=", low_thresh, " high=", high_thresh
    end subroutine write_pgm_contrast

    !================================================================
    ! Write PGM header
    !================================================================
    subroutine write_pgm_header(unit_num, w, h)
        integer, intent(in) :: unit_num, w, h
        character(len=64) :: header_str
        integer :: hlen

        write(header_str, '(A,A,I0,A,I0,A,A)') &
            "P5", char(10), w, " ", h, char(10), "255"
        hlen = len_trim(header_str)
        write(unit_num) header_str(1:hlen)
        write(unit_num) char(10)
    end subroutine write_pgm_header

end program cryo_denoise_engine_v2
